package crypto

import (
	"bufio"
	"crypto/rand"
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/abdorrahmani/cryptolens/internal/utils"
	"golang.org/x/crypto/chacha20poly1305"
)

// ChaCha20Poly1305Processor implements the Processor interface for ChaCha20-Poly1305 operations
type ChaCha20Poly1305Processor struct {
	BaseConfigurableProcessor
	keyManager KeyManager
	keySize    int
	nonceSize  int
	tagSize    int
}

// NewChaCha20Poly1305Processor creates a new ChaCha20-Poly1305 processor
func NewChaCha20Poly1305Processor() *ChaCha20Poly1305Processor {
	return &ChaCha20Poly1305Processor{
		keySize:   256,
		nonceSize: 12,
		tagSize:   16,
	}
}

// Configure implements the ConfigurableProcessor interface
func (p *ChaCha20Poly1305Processor) Configure(config map[string]interface{}) error {
	if err := p.BaseConfigurableProcessor.Configure(config); err != nil {
		return err
	}

	// Configure key file if provided
	keyFile := "keys/chacha20poly1305_key.bin"
	if kf, ok := config["keyFile"].(string); ok {
		keyFile = kf
	}

	// Initialize key manager
	p.keyManager = NewFileKeyManager(256, keyFile) // ChaCha20-Poly1305 uses 256-bit keys
	if err := p.keyManager.LoadOrGenerateKey(); err != nil {
		return fmt.Errorf("failed to load/generate key: %w", err)
	}

	// Configure key size if provided
	if keySize, ok := config["keySize"].(int); ok {
		if keySize != 256 {
			return fmt.Errorf("invalid key size: %d (must be 256 bits)", keySize)
		}
		p.keySize = keySize
	}

	// Configure nonce size if provided
	if nonceSize, ok := config["nonceSize"].(int); ok {
		if nonceSize != 12 {
			return fmt.Errorf("invalid nonce size: %d (must be 12 bytes)", nonceSize)
		}
		p.nonceSize = nonceSize
	}

	// Configure tag size if provided
	if tagSize, ok := config["tagSize"].(int); ok {
		if tagSize != 16 {
			return fmt.Errorf("invalid tag size: %d (must be 16 bytes)", tagSize)
		}
		p.tagSize = tagSize
	}

	return nil
}

// Process implements the Processor interface
func (p *ChaCha20Poly1305Processor) Process(text string, operation string) (string, []string, error) {
	v := utils.NewVisualizer()

	// Add introduction
	v.AddStep("🔐 ChaCha20-Poly1305 Process")
	v.AddStep("=============================")
	v.AddStep("ChaCha20-Poly1305 is an authenticated encryption algorithm")
	v.AddStep("It combines the ChaCha20 stream cipher with the Poly1305 MAC")
	v.AddStep("Provides both confidentiality and authenticity")
	v.AddSeparator()

	// Add length explanations
	v.AddStep("📏 Key Lengths")
	v.AddStep("=============")
	v.AddStep("Key: 32 bytes (256 bits)")
	v.AddStep("• Used for both ChaCha20 encryption and Poly1305 MAC")
	v.AddStep("• Must be kept secret and secure")
	v.AddStep("• Never reuse the same key with different nonces")
	v.AddSeparator()

	v.AddStep("Nonce: 12 bytes (96 bits)")
	v.AddStep("• Must be unique for each encryption")
	v.AddStep("• Never reuse a nonce with the same key")
	v.AddStep("• Nonce reuse can lead to complete security failure")
	v.AddSeparator()

	v.AddStep("Tag: 16 bytes (128 bits)")
	v.AddStep("• Authentication tag generated by Poly1305")
	v.AddStep("• Ensures message integrity and authenticity")
	v.AddStep("• Must be verified during decryption")
	v.AddSeparator()

	// Add ASCII Diagram
	v.AddStep("Encryption Flow:")
	v.AddStep("┌─────────────┐")
	v.AddStep("│  Plaintext  │")
	v.AddStep("└──────┬──────┘")
	v.AddStep("       │")
	v.AddStep("       v")
	v.AddStep("┌─────────────┐")
	v.AddStep("│    Key      │")
	v.AddStep("└──────┬──────┘")
	v.AddStep("       │")
	v.AddStep("       v")
	v.AddStep("┌─────────────┐")
	v.AddStep("│    Nonce    │")
	v.AddStep("└──────┬──────┘")
	v.AddStep("       │")
	v.AddStep("       v")
	v.AddStep("┌─────────────┐")
	v.AddStep("│ ChaCha20    │")
	v.AddStep("│ Encryption  │")
	v.AddStep("└──────┬──────┘")
	v.AddStep("       │")
	v.AddStep("       v")
	v.AddStep("┌─────────────┐")
	v.AddStep("│ Poly1305    │")
	v.AddStep("│    MAC      │")
	v.AddStep("└──────┬──────┘")
	v.AddStep("       │")
	v.AddStep("       v")
	v.AddStep("┌─────────────┐")
	v.AddStep("│ Ciphertext  │")
	v.AddStep("└─────────────┘")
	v.AddSeparator()

	// Add Tutorial Section
	v.AddStep("📚 Tutorial: Understanding ChaCha20-Poly1305")
	v.AddStep("=========================================")
	v.AddStep("1. ChaCha20 Stream Cipher:")
	v.AddStep("   • Fast and secure stream cipher")
	v.AddStep("   • Resistant to timing attacks")
	v.AddStep("   • Constant-time operations")
	v.AddStep("   • Used in TLS 1.3 and other protocols")
	v.AddSeparator()

	v.AddStep("2. Poly1305 MAC:")
	v.AddStep("   • Fast and secure message authentication")
	v.AddStep("   • 128-bit security level")
	v.AddStep("   • Resistant to timing attacks")
	v.AddStep("   • Used for message integrity")
	v.AddSeparator()

	v.AddStep("3. Combined Benefits:")
	v.AddStep("   • Authenticated encryption")
	v.AddStep("   • High performance")
	v.AddStep("   • Strong security guarantees")
	v.AddStep("   • Wide adoption in modern protocols")
	v.AddSeparator()

	v.AddStep("4. Security Properties:")
	v.AddStep("   • Confidentiality (ChaCha20)")
	v.AddStep("   • Integrity (Poly1305)")
	v.AddStep("   • Authentication (Poly1305)")
	v.AddStep("   • Nonce reuse resistance")
	v.AddSeparator()

	if operation == OperationEncrypt {
		return p.encrypt(text, v)
	}
	return p.decrypt(text, v)
}

func (p *ChaCha20Poly1305Processor) encrypt(text string, v *utils.Visualizer) (string, []string, error) {
	// Show original text
	v.AddStep("Step 1: Input Processing")
	v.AddStep("----------------------")
	v.AddTextStep("Original Text", text)
	v.AddArrow()

	// Ask for key input preference
	v.AddStep("Step 2: Key Management")
	v.AddStep("---------------------")
	fmt.Printf("\n%s", utils.DefaultTheme.Format("Key Management:", "brightCyan"))
	fmt.Printf("\n%s", utils.DefaultTheme.Format("1. Use existing key", "yellow"))
	fmt.Printf("\n%s", utils.DefaultTheme.Format("2. Enter custom key (32 bytes in hex)", "yellow"))
	fmt.Printf("\n%s", utils.DefaultTheme.Format("Enter your choice (1-2): ", "brightGreen"))

	var key []byte
	var err error
	choice := ""
	if input, err := bufio.NewReader(os.Stdin).ReadString('\n'); err == nil {
		choice = strings.TrimSpace(input)
	}

	if choice == "2" {
		fmt.Printf("%s", utils.DefaultTheme.Format("Enter 32-byte key in hex format: ", "brightGreen"))
		keyHex := ""
		if input, err := bufio.NewReader(os.Stdin).ReadString('\n'); err == nil {
			keyHex = strings.TrimSpace(input)
		}
		key, err = hex.DecodeString(keyHex)
		if err != nil || len(key) != 32 {
			return "", nil, fmt.Errorf("invalid key: must be 32 bytes in hex format")
		}
		v.AddStep("Using custom key")
		v.AddStep("⚠️ Warning: Ensure the key is kept secure and not reused")
	} else {
		key = p.keyManager.GetKey()
		v.AddStep("Using existing key from key manager")
	}

	v.AddHexStep("Encryption Key", key)
	v.AddArrow()

	// Create ChaCha20-Poly1305 cipher
	v.AddStep("Step 3: Cipher Initialization")
	v.AddStep("---------------------------")
	aead, err := chacha20poly1305.New(key)
	if err != nil {
		return "", nil, fmt.Errorf("failed to create cipher: %w", err)
	}
	v.AddStep("✅ Cipher initialized successfully")
	v.AddArrow()

	// Ask for nonce input preference
	v.AddStep("Step 4: Nonce Management")
	v.AddStep("----------------------")
	fmt.Printf("\n%s", utils.DefaultTheme.Format("Nonce Management:", "brightCyan"))
	fmt.Printf("\n%s", utils.DefaultTheme.Format("1. Generate random nonce", "yellow"))
	fmt.Printf("\n%s", utils.DefaultTheme.Format("2. Enter custom nonce (12 bytes in hex)", "yellow"))
	fmt.Printf("\n%s", utils.DefaultTheme.Format("Enter your choice (1-2): ", "brightGreen"))

	var nonce []byte
	choice = ""
	if input, err := bufio.NewReader(os.Stdin).ReadString('\n'); err == nil {
		choice = strings.TrimSpace(input)
	}

	if choice == "2" {
		fmt.Printf("%s", utils.DefaultTheme.Format("Enter 12-byte nonce in hex format: ", "brightGreen"))
		nonceHex := ""
		if input, err := bufio.NewReader(os.Stdin).ReadString('\n'); err == nil {
			nonceHex = strings.TrimSpace(input)
		}
		nonce, err = hex.DecodeString(nonceHex)
		if err != nil || len(nonce) != 12 {
			return "", nil, fmt.Errorf("invalid nonce: must be 12 bytes in hex format")
		}
		v.AddStep("Using custom nonce")
		v.AddStep("⚠️ WARNING: Never reuse a nonce with the same key")
		v.AddStep("⚠️ WARNING: Nonce reuse can lead to complete security failure")
		v.AddStep("⚠️ WARNING: Each encryption should use a unique nonce")
	} else {
		nonce = make([]byte, p.nonceSize)
		if _, err := rand.Read(nonce); err != nil {
			return "", nil, fmt.Errorf("failed to generate nonce: %w", err)
		}
		v.AddStep("Using randomly generated nonce")
		v.AddStep("✅ The nonce is cryptographically secure and unique")
	}

	v.AddHexStep("Nonce", nonce)
	v.AddArrow()

	// Get AAD from user
	v.AddStep("Step 5: Additional Authenticated Data (AAD)")
	v.AddStep("----------------------------------------")
	fmt.Printf("\n%s", utils.DefaultTheme.Format("Enter Additional Authenticated Data (AAD) or press Enter to skip: ", "brightGreen bold"))
	aad := ""
	if input, err := bufio.NewReader(os.Stdin).ReadString('\n'); err == nil {
		aad = strings.TrimSpace(input)
	}

	if aad != "" {
		v.AddTextStep("Additional Authenticated Data (AAD)", aad)
		v.AddStep("AAD is authenticated but not encrypted")
		v.AddStep("If AAD changes during decryption, the operation will fail")
		v.AddStep("Useful for protecting associated metadata")
		v.AddArrow()
	}

	// Measure execution time
	v.AddStep("Step 6: Encryption Process")
	v.AddStep("------------------------")
	startTime := time.Now()
	ciphertext := aead.Seal(nil, nonce, []byte(text), []byte(aad))
	executionTime := time.Since(startTime)

	// Format execution time
	var timeStr string
	if executionTime < time.Millisecond {
		timeStr = fmt.Sprintf("%.3fµs", float64(executionTime.Nanoseconds())/1000.0)
	} else {
		timeStr = fmt.Sprintf("%.3fms", float64(executionTime.Milliseconds()))
	}
	v.AddStep(fmt.Sprintf("Encryption time: %s", timeStr))

	// Extract ciphertext and tag
	actualCiphertext := ciphertext[:len(ciphertext)-p.tagSize]
	tag := ciphertext[len(ciphertext)-p.tagSize:]

	// Show ciphertext and tag separately
	v.AddHexStep("Ciphertext (without tag)", actualCiphertext)
	v.AddArrow()
	v.AddHexStep("Authentication Tag", tag)
	v.AddArrow()

	// Combine nonce, ciphertext, and tag
	result := append(nonce, ciphertext...)

	// Show final result in different formats
	v.AddStep("Step 7: Final Result")
	v.AddStep("------------------")
	v.AddTextStep("Final Result (Hex)", hex.EncodeToString(result))
	v.AddTextStep("Final Result (Base64)", base64.StdEncoding.EncodeToString(result))

	// Add security notes
	v.AddSeparator()
	v.AddStep("🔒 Security Considerations")
	v.AddStep("========================")
	v.AddStep("1. ChaCha20-Poly1305 provides both confidentiality and authenticity")
	v.AddStep("2. The key must be kept secret and secure")
	v.AddStep("3. The nonce must be unique for each encryption")
	v.AddStep("4. The authentication tag ensures message integrity")
	v.AddStep("5. ChaCha20-Poly1305 is resistant to timing attacks")
	if aad != "" {
		v.AddStep("6. AAD provides additional authentication for associated metadata")
		v.AddStep("7. Any change to AAD will cause decryption to fail")
	}
	if choice == "2" {
		v.AddStep("8. Using custom key - ensure it's kept secure")
		v.AddStep("9. Using custom nonce - ensure it's never reused")
	}

	return base64.StdEncoding.EncodeToString(result), v.GetSteps(), nil
}

func (p *ChaCha20Poly1305Processor) decrypt(text string, v *utils.Visualizer) (string, []string, error) {
	// Decode input
	v.AddStep("Step 1: Input Processing")
	v.AddStep("----------------------")
	decoded, err := base64.StdEncoding.DecodeString(text)
	if err != nil {
		return "", nil, fmt.Errorf("failed to decode input: %w", err)
	}

	// Show input
	v.AddTextStep("Input (Base64)", text)
	v.AddArrow()

	// Extract nonce and ciphertext
	v.AddStep("Step 2: Data Extraction")
	v.AddStep("---------------------")
	if len(decoded) < p.nonceSize {
		return "", nil, fmt.Errorf("input too short")
	}
	nonce := decoded[:p.nonceSize]
	ciphertext := decoded[p.nonceSize:]

	v.AddHexStep("Extracted Nonce", nonce)
	v.AddArrow()

	// Extract actual ciphertext and tag
	actualCiphertext := ciphertext[:len(ciphertext)-p.tagSize]
	tag := ciphertext[len(ciphertext)-p.tagSize:]

	v.AddHexStep("Extracted Ciphertext (without tag)", actualCiphertext)
	v.AddArrow()
	v.AddHexStep("Extracted Authentication Tag", tag)
	v.AddArrow()

	// Ask for key input preference
	v.AddStep("Step 3: Key Management")
	v.AddStep("---------------------")
	fmt.Printf("\n%s", utils.DefaultTheme.Format("Key Management:", "brightCyan"))
	fmt.Printf("\n%s", utils.DefaultTheme.Format("1. Use existing key", "yellow"))
	fmt.Printf("\n%s", utils.DefaultTheme.Format("2. Enter custom key (32 bytes in hex)", "yellow"))
	fmt.Printf("\n%s", utils.DefaultTheme.Format("Enter your choice (1-2): ", "brightGreen"))

	var key []byte
	choice := ""
	if input, err := bufio.NewReader(os.Stdin).ReadString('\n'); err == nil {
		choice = strings.TrimSpace(input)
	}

	if choice == "2" {
		fmt.Printf("%s", utils.DefaultTheme.Format("Enter 32-byte key in hex format: ", "brightGreen"))
		keyHex := ""
		if input, err := bufio.NewReader(os.Stdin).ReadString('\n'); err == nil {
			keyHex = strings.TrimSpace(input)
		}
		key, err = hex.DecodeString(keyHex)
		if err != nil || len(key) != 32 {
			return "", nil, fmt.Errorf("invalid key: must be 32 bytes in hex format")
		}
		v.AddStep("Using custom key")
		v.AddStep("⚠️ Warning: Ensure the key is kept secure and not reused")
	} else {
		key = p.keyManager.GetKey()
		v.AddStep("Using existing key from key manager")
	}

	v.AddHexStep("Decryption Key", key)
	v.AddArrow()

	// Get AAD from user
	v.AddStep("Step 4: Additional Authenticated Data (AAD)")
	v.AddStep("----------------------------------------")
	fmt.Printf("\n%s", utils.DefaultTheme.Format("Enter Additional Authenticated Data (AAD) or press Enter to skip: ", "brightGreen"))
	aad := ""
	if input, err := bufio.NewReader(os.Stdin).ReadString('\n'); err == nil {
		aad = strings.TrimSpace(input)
	}

	if aad != "" {
		v.AddTextStep("Additional Authenticated Data (AAD)", aad)
		v.AddStep("AAD must match the one used during encryption")
		v.AddStep("Any change to AAD will cause decryption to fail")
		v.AddStep("This ensures the associated metadata hasn't been tampered with")
		v.AddArrow()
	}

	// Create ChaCha20-Poly1305 cipher
	v.AddStep("Step 5: Cipher Initialization")
	v.AddStep("---------------------------")
	aead, err := chacha20poly1305.New(key)
	if err != nil {
		return "", nil, fmt.Errorf("failed to create cipher: %w", err)
	}
	v.AddStep("✅ Cipher initialized successfully")
	v.AddArrow()

	// Measure execution time
	v.AddStep("Step 6: Decryption Process")
	v.AddStep("------------------------")
	startTime := time.Now()
	plaintext, err := aead.Open(nil, nonce, ciphertext, []byte(aad))
	executionTime := time.Since(startTime)

	if err != nil {
		v.AddStep("❌ Decryption Failed:")
		v.AddStep(fmt.Sprintf("Error: %v", err))
		if aad != "" {
			v.AddStep("The error might be due to:")
			v.AddStep("1. Incorrect AAD")
			v.AddStep("2. Tampered ciphertext")
			v.AddStep("3. Invalid authentication tag")
		}
		if choice == "2" {
			v.AddStep("4. Incorrect custom key")
		}
		return "", v.GetSteps(), fmt.Errorf("decryption failed: %w", err)
	}

	// Format execution time
	var timeStr string
	if executionTime < time.Millisecond {
		timeStr = fmt.Sprintf("%.3fµs", float64(executionTime.Nanoseconds())/1000.0)
	} else {
		timeStr = fmt.Sprintf("%.3fms", float64(executionTime.Milliseconds()))
	}
	v.AddStep(fmt.Sprintf("Decryption time: %s", timeStr))

	// Show decrypted text
	v.AddStep("Step 7: Final Result")
	v.AddStep("------------------")
	v.AddTextStep("Decrypted Text", string(plaintext))

	// Add security notes
	v.AddSeparator()
	v.AddStep("🔒 Security Considerations")
	v.AddStep("========================")
	v.AddStep("1. The authentication tag is verified during decryption")
	v.AddStep("2. If the tag is invalid, decryption fails")
	v.AddStep("3. This ensures both confidentiality and authenticity")
	v.AddStep("4. The key must be kept secret and secure")
	v.AddStep("5. The nonce must match the one used during encryption")
	if aad != "" {
		v.AddStep("6. AAD provides additional authentication for associated metadata")
		v.AddStep("7. Any change to AAD will cause decryption to fail")
	}
	if choice == "2" {
		v.AddStep("8. Using custom key - ensure it's kept secure")
		v.AddStep("9. Using custom nonce - ensure it's never reused")
	}

	return string(plaintext), v.GetSteps(), nil
}

package crypto

import (
	"bufio"
	"crypto/rand"
	"encoding/base64"
	"encoding/hex"
	"fmt"
	"os"
	"strings"
	"time"

	"github.com/abdorrahmani/cryptolens/internal/utils"
	"golang.org/x/crypto/chacha20poly1305"
)

// ChaCha20Poly1305Processor implements the Processor interface for ChaCha20-Poly1305 operations
type ChaCha20Poly1305Processor struct {
	BaseConfigurableProcessor
	keyManager KeyManager
	keySize    int
	nonceSize  int
	tagSize    int
}

// NewChaCha20Poly1305Processor creates a new ChaCha20-Poly1305 processor
func NewChaCha20Poly1305Processor() *ChaCha20Poly1305Processor {
	return &ChaCha20Poly1305Processor{
		keySize:   256,
		nonceSize: 12,
		tagSize:   16,
	}
}

// Configure implements the ConfigurableProcessor interface
func (p *ChaCha20Poly1305Processor) Configure(config map[string]interface{}) error {
	if err := p.BaseConfigurableProcessor.Configure(config); err != nil {
		return err
	}

	// Configure key file if provided
	keyFile := "keys/chacha20poly1305_key.bin"
	if kf, ok := config["keyFile"].(string); ok {
		keyFile = kf
	}

	// Initialize key manager
	p.keyManager = NewFileKeyManager(256, keyFile) // ChaCha20-Poly1305 uses 256-bit keys
	if err := p.keyManager.LoadOrGenerateKey(); err != nil {
		return fmt.Errorf("failed to load/generate key: %w", err)
	}

	// Configure key size if provided
	if keySize, ok := config["keySize"].(int); ok {
		if keySize != 256 {
			return fmt.Errorf("invalid key size: %d (must be 256 bits)", keySize)
		}
		p.keySize = keySize
	}

	// Configure nonce size if provided
	if nonceSize, ok := config["nonceSize"].(int); ok {
		if nonceSize != 12 {
			return fmt.Errorf("invalid nonce size: %d (must be 12 bytes)", nonceSize)
		}
		p.nonceSize = nonceSize
	}

	// Configure tag size if provided
	if tagSize, ok := config["tagSize"].(int); ok {
		if tagSize != 16 {
			return fmt.Errorf("invalid tag size: %d (must be 16 bytes)", tagSize)
		}
		p.tagSize = tagSize
	}

	return nil
}

// Process implements the Processor interface
func (p *ChaCha20Poly1305Processor) Process(text string, operation string) (string, []string, error) {
	v := utils.NewVisualizer()

	// Add introduction
	v.AddStep("🔐 ChaCha20-Poly1305 Process")
	v.AddStep("=============================")
	v.AddStep("ChaCha20-Poly1305 is an authenticated encryption algorithm")
	v.AddStep("It combines the ChaCha20 stream cipher with the Poly1305 MAC")
	v.AddStep("Provides both confidentiality and authenticity")
	v.AddSeparator()

	// Add length explanations
	v.AddStep("📏 Key Lengths")
	v.AddStep("=============")
	v.AddStep("Key: 32 bytes (256 bits)")
	v.AddStep("• Used for both ChaCha20 encryption and Poly1305 MAC")
	v.AddStep("• Must be kept secret and secure")
	v.AddStep("• Never reuse the same key with different nonces")
	v.AddSeparator()

	v.AddStep("Nonce: 12 bytes (96 bits)")
	v.AddStep("• Must be unique for each encryption")
	v.AddStep("• Never reuse a nonce with the same key")
	v.AddStep("• Nonce reuse can lead to complete security failure")
	v.AddSeparator()

	v.AddStep("Tag: 16 bytes (128 bits)")
	v.AddStep("• Authentication tag generated by Poly1305")
	v.AddStep("• Ensures message integrity and authenticity")
	v.AddStep("• Must be verified during decryption")
	v.AddSeparator()

	// Add ASCII Diagram
	v.AddStep("Encryption Flow:")
	v.AddStep("┌─────────────┐")
	v.AddStep("│  Plaintext  │")
	v.AddStep("└──────┬──────┘")
	v.AddStep("       │")
	v.AddStep("       v")
	v.AddStep("┌─────────────┐")
	v.AddStep("│    Key      │")
	v.AddStep("└──────┬──────┘")
	v.AddStep("       │")
	v.AddStep("       v")
	v.AddStep("┌─────────────┐")
	v.AddStep("│    Nonce    │")
	v.AddStep("└──────┬──────┘")
	v.AddStep("       │")
	v.AddStep("       v")
	v.AddStep("┌─────────────┐")
	v.AddStep("│ ChaCha20    │")
	v.AddStep("│ Encryption  │")
	v.AddStep("└──────┬──────┘")
	v.AddStep("       │")
	v.AddStep("       v")
	v.AddStep("┌─────────────┐")
	v.AddStep("│ Poly1305    │")
	v.AddStep("│    MAC      │")
	v.AddStep("└──────┬──────┘")
	v.AddStep("       │")
	v.AddStep("       v")
	v.AddStep("┌─────────────┐")
	v.AddStep("│ Ciphertext  │")
	v.AddStep("└─────────────┘")
	v.AddSeparator()

	// Add Tutorial Section
	v.AddStep("📚 Tutorial: Understanding ChaCha20-Poly1305")
	v.AddStep("=========================================")
	v.AddStep("1. ChaCha20 Stream Cipher:")
	v.AddStep("   • Fast and secure stream cipher")
	v.AddStep("   • Resistant to timing attacks")
	v.AddStep("   • Constant-time operations")
	v.AddStep("   • Used in TLS 1.3 and other protocols")
	v.AddSeparator()

	v.AddStep("2. Poly1305 MAC:")
	v.AddStep("   • Fast and secure message authentication")
	v.AddStep("   • 128-bit security level")
	v.AddStep("   • Resistant to timing attacks")
	v.AddStep("   • Used for message integrity")
	v.AddSeparator()

	v.AddStep("3. Combined Benefits:")
	v.AddStep("   • Authenticated encryption")
	v.AddStep("   • High performance")
	v.AddStep("   • Strong security guarantees")
	v.AddStep("   • Wide adoption in modern protocols")
	v.AddSeparator()

	v.AddStep("4. Security Properties:")
	v.AddStep("   • Confidentiality (ChaCha20)")
	v.AddStep("   • Integrity (Poly1305)")
	v.AddStep("   • Authentication (Poly1305)")
	v.AddStep("   • Nonce reuse resistance")
	v.AddSeparator()

	// Add Tampering Test Section
	v.AddStep("Tampering Test")
	v.AddStep("================")
	v.AddStep("This section demonstrates how ChaCha20-Poly1305 detects tampering")
	v.AddStep("You can test the authenticity feature by:")
	v.AddStep("1. Encrypting a message")
	v.AddStep("2. Modifying the ciphertext or tag")
	v.AddStep("3. Attempting to decrypt")
	v.AddStep("4. Observing the authentication failure")
	v.AddSeparator()

	v.AddStep("Example Tampering Tests:")
	v.AddStep("1. Modify a single byte in the ciphertext")
	v.AddStep("2. Change the authentication tag")
	v.AddStep("3. Alter the nonce")
	v.AddStep("4. Modify the AAD (if used)")
	v.AddSeparator()

	v.AddStep("Expected Results:")
	v.AddStep("• Any modification will cause decryption to fail")
	v.AddStep("• The error message will indicate authentication failure")
	v.AddStep("• This demonstrates the integrity protection of ChaCha20-Poly1305")
	v.AddSeparator()

	if operation == OperationEncrypt {
		return p.encrypt(text, v)
	}
	return p.decrypt(text, v)
}

func (p *ChaCha20Poly1305Processor) encrypt(text string, v *utils.Visualizer) (string, []string, error) {
	// Show original text
	v.AddStep("Step 1: Input Processing")
	v.AddStep("----------------------")
	v.AddTextStep("Original Text", text)
	v.AddArrow()

	// Ask for key input preference
	v.AddStep("Step 2: Key Management")
	v.AddStep("---------------------")
	fmt.Printf("\n%s", utils.DefaultTheme.Format("Key Management:", "brightCyan"))
	fmt.Printf("\n%s", utils.DefaultTheme.Format("1. Use existing key", "yellow"))
	fmt.Printf("\n%s", utils.DefaultTheme.Format("2. Enter custom key (32 bytes in hex)", "yellow"))
	fmt.Printf("\n%s", utils.DefaultTheme.Format("Enter your choice (1-2): ", "brightGreen"))

	var key []byte
	var err error
	choice := ""
	if input, err := bufio.NewReader(os.Stdin).ReadString('\n'); err == nil {
		choice = strings.TrimSpace(input)
	}

	if choice == "2" {
		fmt.Printf("%s", utils.DefaultTheme.Format("Enter 32-byte key in hex format: ", "brightGreen"))
		keyHex := ""
		if input, err := bufio.NewReader(os.Stdin).ReadString('\n'); err == nil {
			keyHex = strings.TrimSpace(input)
		}
		key, err = hex.DecodeString(keyHex)
		if err != nil || len(key) != 32 {
			return "", nil, fmt.Errorf("invalid key: must be 32 bytes in hex format")
		}
		v.AddStep("Using custom key")
		v.AddStep("⚠️ Warning: Ensure the key is kept secure and not reused")
	} else {
		key = p.keyManager.GetKey()
		v.AddStep("Using existing key from key manager")
	}

	v.AddHexStep("Encryption Key", key)
	v.AddArrow()

	// Create ChaCha20-Poly1305 cipher
	v.AddStep("Step 3: Cipher Initialization")
	v.AddStep("---------------------------")
	aead, err := chacha20poly1305.New(key)
	if err != nil {
		return "", nil, fmt.Errorf("failed to create cipher: %w", err)
	}
	v.AddStep("✅ Cipher initialized successfully")
	v.AddArrow()

	// Ask for nonce input preference
	v.AddStep("Step 4: Nonce Management")
	v.AddStep("----------------------")
	fmt.Printf("\n%s", utils.DefaultTheme.Format("Nonce Management:", "brightCyan"))
	fmt.Printf("\n%s", utils.DefaultTheme.Format("1. Generate random nonce", "yellow"))
	fmt.Printf("\n%s", utils.DefaultTheme.Format("2. Enter custom nonce (12 bytes in hex)", "yellow"))
	fmt.Printf("\n%s", utils.DefaultTheme.Format("Enter your choice (1-2): ", "brightGreen"))

	var nonce []byte
	choice = ""
	if input, err := bufio.NewReader(os.Stdin).ReadString('\n'); err == nil {
		choice = strings.TrimSpace(input)
	}

	if choice == "2" {
		fmt.Printf("%s", utils.DefaultTheme.Format("Enter 12-byte nonce in hex format: ", "brightGreen"))
		nonceHex := ""
		if input, err := bufio.NewReader(os.Stdin).ReadString('\n'); err == nil {
			nonceHex = strings.TrimSpace(input)
		}
		nonce, err = hex.DecodeString(nonceHex)
		if err != nil || len(nonce) != 12 {
			return "", nil, fmt.Errorf("invalid nonce: must be 12 bytes in hex format")
		}
		v.AddStep("Using custom nonce")
		v.AddStep("⚠️ WARNING: Never reuse a nonce with the same key")
		v.AddStep("⚠️ WARNING: Nonce reuse can lead to complete security failure")
		v.AddStep("⚠️ WARNING: Each encryption should use a unique nonce")
	} else {
		nonce = make([]byte, p.nonceSize)
		if _, err := rand.Read(nonce); err != nil {
			return "", nil, fmt.Errorf("failed to generate nonce: %w", err)
		}
		v.AddStep("Using randomly generated nonce")
		v.AddStep("✅ The nonce is cryptographically secure and unique")
	}

	v.AddHexStep("Nonce", nonce)
	v.AddArrow()

	// Get AAD from user
	v.AddStep("Step 5: Additional Authenticated Data (AAD)")
	v.AddStep("----------------------------------------")
	fmt.Printf("\n%s", utils.DefaultTheme.Format("Enter Additional Authenticated Data (AAD) or press Enter to skip: ", "brightGreen bold"))
	aad := ""
	if input, err := bufio.NewReader(os.Stdin).ReadString('\n'); err == nil {
		aad = strings.TrimSpace(input)
	}

	if aad != "" {
		v.AddTextStep("Additional Authenticated Data (AAD)", aad)
		v.AddStep("AAD is authenticated but not encrypted")
		v.AddStep("If AAD changes during decryption, the operation will fail")
		v.AddStep("Useful for protecting associated metadata")
		v.AddArrow()
	}

	// Measure execution time
	v.AddStep("Step 6: Encryption Process")
	v.AddStep("------------------------")
	startTime := time.Now()
	ciphertext := aead.Seal(nil, nonce, []byte(text), []byte(aad))
	executionTime := time.Since(startTime)

	// Format execution time
	var timeStr string
	if executionTime < time.Millisecond {
		timeStr = fmt.Sprintf("%.3fµs", float64(executionTime.Nanoseconds())/1000.0)
	} else {
		timeStr = fmt.Sprintf("%.3fms", float64(executionTime.Milliseconds()))
	}
	v.AddStep(fmt.Sprintf("Encryption time: %s", timeStr))

	// Extract ciphertext and tag
	actualCiphertext := ciphertext[:len(ciphertext)-p.tagSize]
	tag := ciphertext[len(ciphertext)-p.tagSize:]

	// Show ciphertext and tag separately
	v.AddHexStep("Ciphertext (without tag)", actualCiphertext)
	v.AddArrow()
	v.AddHexStep("Authentication Tag", tag)
	v.AddArrow()

	// Combine nonce, ciphertext, and tag
	result := append(nonce, ciphertext...)

	// Show final result in different formats
	v.AddStep("Step 7: Final Result")
	v.AddStep("------------------")
	v.AddTextStep("Final Result (Hex)", hex.EncodeToString(result))
	v.AddTextStep("Final Result (Base64)", base64.StdEncoding.EncodeToString(result))

	// Add security notes
	v.AddSeparator()
	v.AddStep("🔒 Security Considerations")
	v.AddStep("========================")
	v.AddStep("1. ChaCha20-Poly1305 provides both confidentiality and authenticity")
	v.AddStep("2. The key must be kept secret and secure")
	v.AddStep("3. The nonce must be unique for each encryption")
	v.AddStep("4. The authentication tag ensures message integrity")
	v.AddStep("5. ChaCha20-Poly1305 is resistant to timing attacks")
	if aad != "" {
		v.AddStep("6. AAD provides additional authentication for associated metadata")
		v.AddStep("7. Any change to AAD will cause decryption to fail")
	}
	if choice == "2" {
		v.AddStep("8. Using custom key - ensure it's kept secure")
		v.AddStep("9. Using custom nonce - ensure it's never reused")
	}

	return base64.StdEncoding.EncodeToString(result), v.GetSteps(), nil
}

func (p *ChaCha20Poly1305Processor) decrypt(text string, v *utils.Visualizer) (string, []string, error) {
	// Decode input
	v.AddStep("Step 1: Input Processing")
	v.AddStep("----------------------")
	decoded, err := base64.StdEncoding.DecodeString(text)
	if err != nil {
		v.AddStep("❌ Error: Invalid base64 input")
		return "", v.GetSteps(), fmt.Errorf("failed to decode input: %w", err)
	}

	// Show input
	v.AddTextStep("Input (Base64)", text)
	v.AddArrow()

	// Extract nonce and ciphertext
	v.AddStep("Step 2: Data Extraction")
	v.AddStep("---------------------")
	if len(decoded) < p.nonceSize {
		v.AddStep("❌ Error: Input too short")
		return "", v.GetSteps(), fmt.Errorf("input too short")
	}
	nonce := decoded[:p.nonceSize]
	ciphertext := decoded[p.nonceSize:]

	v.AddHexStep("Extracted Nonce", nonce)
	v.AddArrow()

	// Extract actual ciphertext and tag
	actualCiphertext := ciphertext[:len(ciphertext)-p.tagSize]
	tag := ciphertext[len(ciphertext)-p.tagSize:]

	v.AddHexStep("Extracted Ciphertext (without tag)", actualCiphertext)
	v.AddArrow()
	v.AddHexStep("Extracted Authentication Tag", tag)
	v.AddArrow()

	// Interactive Tampering Test
	v.AddStep("Step 3: Tampering Test")
	v.AddStep("---------------------")
	fmt.Printf("\n%s", utils.DefaultTheme.Format("Do you want to simulate tampering?", "brightCyan"))
	fmt.Printf("\n%s", utils.DefaultTheme.Format("1. No tampering", "yellow"))
	fmt.Printf("\n%s", utils.DefaultTheme.Format("2. Flip a bit in ciphertext", "yellow"))
	fmt.Printf("\n%s", utils.DefaultTheme.Format("3. Corrupt the tag", "yellow"))
	fmt.Printf("\n%s", utils.DefaultTheme.Format("Enter your choice (1-3): ", "brightGreen"))

	choice := ""
	if input, err := bufio.NewReader(os.Stdin).ReadString('\n'); err == nil {
		choice = strings.TrimSpace(input)
	}

	// Show simulation details
	v.AddStep("Simulation Details:")
	v.AddStep("-----------------")
	switch choice {
	case "2":
		// Flip a random bit in the ciphertext
		if len(actualCiphertext) > 0 {
			byteIndex := 0
			bitIndex := 0
			originalByte := actualCiphertext[byteIndex]
			actualCiphertext[byteIndex] ^= 1 << bitIndex
			v.AddStep("⚠️ Simulating ciphertext tampering:")
			v.AddStep(fmt.Sprintf("• Original byte at position 0: %08b", originalByte))
			v.AddStep(fmt.Sprintf("• Modified byte at position 0: %08b", actualCiphertext[byteIndex]))
			v.AddStep("• Flipped bit 0 in the first byte")
			v.AddStep("❌ This modification will cause authentication to fail!")
			v.AddStep("Original Ciphertext (hex): " + hex.EncodeToString([]byte{originalByte}))
			v.AddStep("Modified Ciphertext (hex): " + hex.EncodeToString([]byte{actualCiphertext[byteIndex]}))
			// Reconstruct the ciphertext with the modified data
			ciphertext = append(actualCiphertext, tag...)
			v.AddStep("Modified Data:")
			v.AddStep("-------------")
			v.AddHexStep("Modified Ciphertext", ciphertext)
		}
	case "3":
		// Corrupt the tag
		if len(tag) > 0 {
			originalTag := make([]byte, len(tag))
			copy(originalTag, tag)
			tag[0] ^= 0xFF // Flip all bits in first byte
			v.AddStep("⚠️ Simulating tag corruption:")
			v.AddStep(fmt.Sprintf("• Original tag (first byte): %08b", originalTag[0]))
			v.AddStep(fmt.Sprintf("• Corrupted tag (first byte): %08b", tag[0]))
			v.AddStep("• Flipped all bits in the first byte of the tag")
			v.AddStep("❌ This corruption will cause authentication to fail!")
			v.AddStep("Original Tag (hex): " + hex.EncodeToString(originalTag[:1]))
			v.AddStep("Modified Tag (hex): " + hex.EncodeToString(tag[:1]))
			// Reconstruct the ciphertext with the modified tag
			ciphertext = append(actualCiphertext, tag...)
			v.AddStep("Modified Data:")
			v.AddStep("-------------")
			v.AddHexStep("Modified Ciphertext", ciphertext)
		}
	default:
		v.AddStep("✅ No tampering simulated")
	}
	v.AddSeparator()

	// Ask for key input preference
	v.AddStep("Step 4: Key Management")
	v.AddStep("---------------------")
	fmt.Printf("\n%s", utils.DefaultTheme.Format("Key Management:", "brightCyan"))
	fmt.Printf("\n%s", utils.DefaultTheme.Format("1. Use existing key", "yellow"))
	fmt.Printf("\n%s", utils.DefaultTheme.Format("2. Enter custom key (32 bytes in hex)", "yellow"))
	fmt.Printf("\n%s", utils.DefaultTheme.Format("Enter your choice (1-2): ", "brightGreen"))

	var key []byte
	choice = ""
	if input, err := bufio.NewReader(os.Stdin).ReadString('\n'); err == nil {
		choice = strings.TrimSpace(input)
	}

	if choice == "2" {
		fmt.Printf("%s", utils.DefaultTheme.Format("Enter 32-byte key in hex format: ", "brightGreen"))
		keyHex := ""
		if input, err := bufio.NewReader(os.Stdin).ReadString('\n'); err == nil {
			keyHex = strings.TrimSpace(input)
		}
		key, err = hex.DecodeString(keyHex)
		if err != nil || len(key) != 32 {
			v.AddStep("❌ Error: Invalid key format or length")
			return "", v.GetSteps(), fmt.Errorf("invalid key: must be 32 bytes in hex format")
		}
		v.AddStep("Using custom key")
		v.AddStep("⚠️ Warning: Ensure the key is kept secure and not reused")
	} else {
		key = p.keyManager.GetKey()
		v.AddStep("Using existing key from key manager")
	}

	v.AddHexStep("Decryption Key", key)
	v.AddArrow()

	// Get AAD from user
	v.AddStep("Step 5: Additional Authenticated Data (AAD)")
	v.AddStep("----------------------------------------")
	fmt.Printf("\n%s", utils.DefaultTheme.Format("Enter Additional Authenticated Data (AAD) or press Enter to skip: ", "brightGreen"))
	aad := ""
	if input, err := bufio.NewReader(os.Stdin).ReadString('\n'); err == nil {
		aad = strings.TrimSpace(input)
	}

	if aad != "" {
		v.AddTextStep("Additional Authenticated Data (AAD)", aad)
		v.AddStep("AAD must match the one used during encryption")
		v.AddStep("Any change to AAD will cause decryption to fail")
		v.AddStep("This ensures the associated metadata hasn't been tampered with")
		v.AddArrow()
	}

	// Create ChaCha20-Poly1305 cipher
	v.AddStep("Step 6: Cipher Initialization")
	v.AddStep("---------------------------")
	aead, err := chacha20poly1305.New(key)
	if err != nil {
		v.AddStep("❌ Error: Failed to create cipher")
		return "", v.GetSteps(), fmt.Errorf("failed to create cipher: %w", err)
	}
	v.AddStep("✅ Cipher initialized successfully")
	v.AddArrow()

	// Measure execution time
	v.AddStep("Step 7: Decryption Process")
	v.AddStep("------------------------")
	startTime := time.Now()
	plaintext, err := aead.Open(nil, nonce, ciphertext, []byte(aad))
	executionTime := time.Since(startTime)

	// Format execution time
	var timeStr string
	if executionTime < time.Millisecond {
		timeStr = fmt.Sprintf("%.3fµs", float64(executionTime.Nanoseconds())/1000.0)
	} else {
		timeStr = fmt.Sprintf("%.3fms", float64(executionTime.Milliseconds()))
	}
	v.AddStep(fmt.Sprintf("Decryption time: %s", timeStr))

	if err != nil {
		v.AddStep("❌ Authentication Failed!")
		v.AddStep("=========================")
		v.AddStep("The decryption failed because:")
		if choice == "2" {
			v.AddStep("• A bit was flipped in the ciphertext")
			v.AddStep("• This demonstrates how ChaCha20-Poly1305 detects tampering")
			v.AddStep("• The authentication tag verification failed")
			v.AddStep("• This is expected behavior for tampered data")
		} else if choice == "3" {
			v.AddStep("• The authentication tag was corrupted")
			v.AddStep("• This shows how the MAC protects message integrity")
			v.AddStep("• The tag verification failed")
			v.AddStep("• This is expected behavior for tampered data")
		} else {
			v.AddStep("• The message authentication failed")
			v.AddStep("• This could be due to:")
			v.AddStep("  - Incorrect key")
			v.AddStep("  - Tampered ciphertext")
			v.AddStep("  - Modified authentication tag")
			if aad != "" {
				v.AddStep("  - Changed AAD")
			}
		}
		v.AddStep("This is expected behavior for authenticated encryption")
		v.AddStep("It ensures that any modification to the encrypted data is detected")
		return "", v.GetSteps(), fmt.Errorf("message authentication failed: %w", err)
	}

	// Show decrypted text
	v.AddStep("Step 8: Final Result")
	v.AddStep("------------------")
	v.AddTextStep("Decrypted Text", string(plaintext))

	// Add security notes
	v.AddSeparator()
	v.AddStep("🔒 Security Considerations")
	v.AddStep("========================")
	v.AddStep("1. The authentication tag is verified during decryption")
	v.AddStep("2. If the tag is invalid, decryption fails")
	v.AddStep("3. This ensures both confidentiality and authenticity")
	v.AddStep("4. The key must be kept secret and secure")
	v.AddStep("5. The nonce must match the one used during encryption")
	if aad != "" {
		v.AddStep("6. AAD provides additional authentication for associated metadata")
		v.AddStep("7. Any change to AAD will cause decryption to fail")
	}
	if choice == "2" {
		v.AddStep("8. Using custom key - ensure it's kept secure")
		v.AddStep("9. Using custom nonce - ensure it's never reused")
	}

	return string(plaintext), v.GetSteps(), nil
}
